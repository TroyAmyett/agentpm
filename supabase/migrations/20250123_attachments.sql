-- Attachments Table
-- Supports attachments on notes, tasks, and task executions
-- Used for both user uploads (input) and agent-generated files (output)

CREATE TABLE IF NOT EXISTS attachments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  account_id UUID NOT NULL REFERENCES accounts(id) ON DELETE CASCADE,

  -- Polymorphic association: what entity this attachment belongs to
  entity_type TEXT NOT NULL CHECK (entity_type IN ('note', 'task', 'execution')),
  entity_id UUID NOT NULL,

  -- File metadata
  file_name TEXT NOT NULL,
  file_type TEXT NOT NULL,  -- 'html', 'css', 'js', 'md', 'docx', 'pdf', 'image', 'other'
  mime_type TEXT NOT NULL,
  file_size INTEGER NOT NULL,  -- Size in bytes
  storage_path TEXT NOT NULL,  -- Path in Supabase Storage

  -- Optional metadata
  description TEXT,

  -- For agent-generated files, track the source
  source TEXT NOT NULL DEFAULT 'user' CHECK (source IN ('user', 'agent')),

  -- Audit
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID NOT NULL,
  deleted_at TIMESTAMPTZ  -- Soft delete for cleanup
);

-- Indexes for fast lookups
CREATE INDEX IF NOT EXISTS idx_attachments_entity ON attachments(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_attachments_account ON attachments(account_id);
CREATE INDEX IF NOT EXISTS idx_attachments_created_at ON attachments(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_attachments_deleted_at ON attachments(deleted_at) WHERE deleted_at IS NULL;

-- RLS
ALTER TABLE attachments ENABLE ROW LEVEL SECURITY;

-- Users can view attachments in their account
CREATE POLICY "Users can view attachments in their account" ON attachments
  FOR SELECT
  USING (
    deleted_at IS NULL AND
    account_id IN (
      SELECT account_id FROM user_accounts WHERE user_id = auth.uid()
    )
  );

-- Users can create attachments in their account
CREATE POLICY "Users can create attachments in their account" ON attachments
  FOR INSERT
  WITH CHECK (account_id IN (
    SELECT account_id FROM user_accounts WHERE user_id = auth.uid()
  ));

-- Users can update (soft delete) attachments in their account
CREATE POLICY "Users can update attachments in their account" ON attachments
  FOR UPDATE
  USING (account_id IN (
    SELECT account_id FROM user_accounts WHERE user_id = auth.uid()
  ));

-- Users can delete attachments in their account
CREATE POLICY "Users can delete attachments in their account" ON attachments
  FOR DELETE
  USING (account_id IN (
    SELECT account_id FROM user_accounts WHERE user_id = auth.uid()
  ));

-- Comments
COMMENT ON TABLE attachments IS 'File attachments for notes, tasks, and agent executions';
COMMENT ON COLUMN attachments.entity_type IS 'Type of entity: note, task, or execution';
COMMENT ON COLUMN attachments.entity_id IS 'ID of the note, task, or execution';
COMMENT ON COLUMN attachments.storage_path IS 'Path to file in Supabase Storage: attachments/{account_id}/{entity_type}s/{entity_id}/{filename}';
COMMENT ON COLUMN attachments.source IS 'Whether file was uploaded by user or generated by agent';

-- ============================================
-- Storage Bucket Setup
-- ============================================

-- Create the attachments bucket (if running via supabase CLI)
-- Note: This may need to be done via Supabase Dashboard if not supported in migrations
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'attachments',
  'attachments',
  false,  -- Private bucket, requires auth
  26214400,  -- 25MB limit
  ARRAY[
    'text/html',
    'text/css',
    'text/javascript',
    'application/javascript',
    'text/plain',
    'text/markdown',
    'text/csv',
    'application/json',
    'application/pdf',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'image/png',
    'image/jpeg',
    'image/gif',
    'image/webp',
    'image/svg+xml'
  ]
)
ON CONFLICT (id) DO UPDATE SET
  file_size_limit = EXCLUDED.file_size_limit,
  allowed_mime_types = EXCLUDED.allowed_mime_types;

-- Storage RLS Policies
-- Users can only access files in their account's folder

-- SELECT (download) policy
CREATE POLICY "Users can download own account attachments"
ON storage.objects FOR SELECT
USING (
  bucket_id = 'attachments' AND
  (storage.foldername(name))[1] IN (
    SELECT id::text FROM accounts
    WHERE id IN (SELECT account_id FROM user_accounts WHERE user_id = auth.uid())
  )
);

-- INSERT (upload) policy
CREATE POLICY "Users can upload to own account attachments"
ON storage.objects FOR INSERT
WITH CHECK (
  bucket_id = 'attachments' AND
  (storage.foldername(name))[1] IN (
    SELECT id::text FROM accounts
    WHERE id IN (SELECT account_id FROM user_accounts WHERE user_id = auth.uid())
  )
);

-- UPDATE policy
CREATE POLICY "Users can update own account attachments"
ON storage.objects FOR UPDATE
USING (
  bucket_id = 'attachments' AND
  (storage.foldername(name))[1] IN (
    SELECT id::text FROM accounts
    WHERE id IN (SELECT account_id FROM user_accounts WHERE user_id = auth.uid())
  )
);

-- DELETE policy
CREATE POLICY "Users can delete own account attachments"
ON storage.objects FOR DELETE
USING (
  bucket_id = 'attachments' AND
  (storage.foldername(name))[1] IN (
    SELECT id::text FROM accounts
    WHERE id IN (SELECT account_id FROM user_accounts WHERE user_id = auth.uid())
  )
);

-- ============================================
-- Cleanup Function (for scheduled jobs)
-- ============================================

-- Function to clean up old attachments
CREATE OR REPLACE FUNCTION cleanup_old_attachments(
  retention_days INTEGER DEFAULT 30,
  keep_per_task INTEGER DEFAULT 3
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  deleted_count INTEGER := 0;
  rows_affected INTEGER := 0;
  attachment_record RECORD;
BEGIN
  -- Mark old execution attachments for deletion (keep last N per task)
  FOR attachment_record IN
    WITH ranked_attachments AS (
      SELECT
        a.id,
        a.storage_path,
        ROW_NUMBER() OVER (
          PARTITION BY e.task_id
          ORDER BY a.created_at DESC
        ) as rn
      FROM attachments a
      JOIN task_executions e ON a.entity_id = e.id AND a.entity_type = 'execution'
      WHERE a.deleted_at IS NULL
        AND a.source = 'agent'  -- Only auto-cleanup agent-generated files
    )
    SELECT id, storage_path
    FROM ranked_attachments
    WHERE rn > keep_per_task
  LOOP
    -- Soft delete the attachment record
    UPDATE attachments
    SET deleted_at = NOW()
    WHERE id = attachment_record.id;

    deleted_count := deleted_count + 1;
  END LOOP;

  -- Also mark attachments older than retention_days for deletion
  UPDATE attachments
  SET deleted_at = NOW()
  WHERE deleted_at IS NULL
    AND source = 'agent'
    AND created_at < NOW() - (retention_days || ' days')::INTERVAL;

  GET DIAGNOSTICS rows_affected = ROW_COUNT;
  deleted_count := deleted_count + rows_affected;

  RETURN deleted_count;
END;
$$;

COMMENT ON FUNCTION cleanup_old_attachments IS 'Marks old agent-generated attachments for cleanup. Storage files should be deleted separately.';
